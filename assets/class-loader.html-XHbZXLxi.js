import{_ as a,o as e,c as o,e as s}from"./app-Ec_z8kpw.js";const d={},l=s('<h2 id="类加载过程" tabindex="-1"><a class="header-anchor" href="#类加载过程"><span>类加载过程</span></a></h2><p>类的加载过程是<strong>加载</strong>-&gt;<strong>连接</strong>-&gt;<strong>初始化</strong>，其中<strong>连接</strong>过程可以细分为<strong>验证</strong>、<strong>准备</strong>和<strong>解析</strong>过程。</p><h3 id="加载" tabindex="-1"><a class="header-anchor" href="#加载"><span>加载</span></a></h3><p>加载是加载类的第一步，主要三个步骤：</p><ol><li>用全类名获取定义此类的字节流</li><li>将字节流所代表的的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的<code>Class</code>对象，作为方法区数据的访问入口</li></ol><p>类的加载一般是通过双亲委派模型（先在父类里找）处理的。</p><h3 id="验证" tabindex="-1"><a class="header-anchor" href="#验证"><span>验证</span></a></h3><p>验证阶段分别进行文件格式验证、元数据验证、字节码验证和符号引用验证。该阶段主要是确保字节码是真实安全可用的。</p><h3 id="准备" tabindex="-1"><a class="header-anchor" href="#准备"><span>准备</span></a></h3><p>准备阶段正式为类变量分配内存并设置类变量的初始值的阶段，这些内存都在方法区中分配。</p><h3 id="解析" tabindex="-1"><a class="header-anchor" href="#解析"><span>解析</span></a></h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。直接饮用一般是指针或者是偏移量。</p><h3 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化"><span>初始化</span></a></h3><p>初始化是执行初始化方法<code>&lt;clinit&gt;()</code>方法的过程，是类加载的最后一步。<code>&lt;clinit&gt;()</code>方法是编译之后自动生成的方法。有六种情况下必须对类进行初始化</p><ol><li>遇到<code>new</code>，<code>getstatic</code>,<code>putstatic</code>,<code>invokestatic</code>这四条字节码指令时就要初始化对应的类。</li><li>使用反射方法对类调用时，如果类没有初始化，需要先初始化。例如<code>Class.forname(&quot;&quot;)</code>.</li><li>一个类初始化时需要先初始化父类。</li><li>虚拟机启动时主类</li><li>MethodHandle和VarHandle，轻量级反射机制，需要先初始化对应的类。</li><li>接口中的default方法被实现类变更时，接口要初始化。</li></ol><p>总之，如果一个类有隐式的被使用的可能就要被初始化。</p><h2 id="类的卸载" tabindex="-1"><a class="header-anchor" href="#类的卸载"><span>类的卸载</span></a></h2><p>当一个类不再被使用时他的CLass对象就会被GC。卸载需要满足3个要求</p><ol><li>该类的所有对象都被GC，不存在该类对象。</li><li>该类没有被其他地方引用。</li><li>该类的类加载器实例已被GC。</li></ol><p>自定义的累加器是可能被GC的。例如一次性加载所需的类之后这个类就再也用不到了。</p><h2 id="类加载器" tabindex="-1"><a class="header-anchor" href="#类加载器"><span>类加载器</span></a></h2><p>类加载器是一个负责加载类的对象，用于实现类加载过程中的加载步骤。每个Java来都有一个引用指向他的<code>ClassLoader</code>，数组类的不是通过<code>ClassLoader</code>创建的，是JVM直接生成的。</p><h3 id="类加载器加载规则" tabindex="-1"><a class="header-anchor" href="#类加载器加载规则"><span>类加载器加载规则</span></a></h3><p>JVM中的类不是一次性全部加载好的，而是根据需要动态加载。类似于懒加载，只有在用到的时候才去真正的加载。</p><p>已经加载的类会被放在对应的<code>ClassLoader</code>对象里。如果一个类已经被加载过了，就会直接返回该类，否则才会尝试加载。类的唯一性是如何判断的呢？使用二进制名称作为类的唯一名，也就是说同样二进制名称的类只会被加载一次。</p><h3 id="类加载器类别" tabindex="-1"><a class="header-anchor" href="#类加载器类别"><span>类加载器类别</span></a></h3><p>JVM中有三种加载器<code>ClassLoader</code>：</p><ol><li><code>BootstrapClassLoader</code>（启动类加载器）：主要用于加载jdk核心类库以及<code>-Xbootclasspath</code>参数指定路径下的所有类。</li><li><code>ExtensionClassLoader</code>（扩展类加载器）：主要加载<code>%JRE_HOME/lib/ext</code>和<code>java.ext.dir</code>系统变量目录下的jar包和类。</li><li><code>AppClassLoader</code>（应用程序类加载器）：负责加载当前应用classpath的所有jar包和类。</li></ol><h3 id="自定义类加载器" tabindex="-1"><a class="header-anchor" href="#自定义类加载器"><span>自定义类加载器</span></a></h3><p>想要实现自定义类加载器就需要继承<code>ClassLoader</code>抽象类。<code>ClassLoader</code>有两个方法：</p><ol><li><code>loadClass(String name, boolean resolve)</code>：加载二进制名称的类，实现了双亲委派模型。<code>resolve</code>表示是否在加载时调用<code>resolveClass(Class&lt;?&gt; c)</code>方法解析该类。</li><li><code>findClass</code>：根据类的二进制名称来查找类，默认是空方法。</li></ol><p><strong>loadClass</strong>保持了双亲委派模型，如果想要保持双亲委派模型就重写<code>findClass</code>方法。如果想要打破双亲委派模型就要重写<code>loadClass</code>方法。</p><h2 id="双亲委派模型" tabindex="-1"><a class="header-anchor" href="#双亲委派模型"><span>双亲委派模型</span></a></h2><p>简述：双亲委派模型是在加载一个类之前现在父类中查找是否已经查找过了，如果已经注册过了就不用再注册了，如果没找到再由子类去完成加载。</p><p>每个类加载器都会尝试让父亲去查找该资源，直到底层加载器也没有找到时才会停止。需要注意的是<code>BoostrapClassLoader</code>的父加载器是<code>null</code>。</p><p>双亲委派模型并不是强制的，而是一种规范，用户可以根据自己的需要来打破双亲委派模型来满足自己的需求。</p><p>实现自定义的类加载一般是通过组合而不是继承，例如在一个类加载中显示的注册一个<code>parent</code>类加载器。这一规则来源于：<strong>组合优于继承，多用组合少用继承</strong>。</p><h3 id="双亲委派模型执行过程" tabindex="-1"><a class="header-anchor" href="#双亲委派模型执行过程"><span>双亲委派模型执行过程</span></a></h3><ol><li>检查该类是否已经加载过。</li><li>如果没有加载过此时判断是否有父加载器，有则使用父加载器进行加载，没有父加载器就用<code>BootstrapClassLoader</code>来尝试加载该类。</li><li>如果父类加载器无法加载该类则调用当前类的<code>findClass</code>方法来加载类。</li><li>最后无法加载则会抛出<code>ClassNotFoundException</code>。</li></ol><h3 id="双亲委派模型的优势" tabindex="-1"><a class="header-anchor" href="#双亲委派模型的优势"><span>双亲委派模型的优势</span></a></h3><ol><li>避免类的重复加载</li><li>保证了Java的核心API不被篡改。</li></ol>',41),c=[l];function n(i,r){return e(),o("div",null,c)}const p=a(d,[["render",n],["__file","class-loader.html.vue"]]);export{p as default};
