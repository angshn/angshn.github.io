import{_ as l,o as n,c as e,e as a}from"./app-Ec_z8kpw.js";const i={},s=a('<h2 id="申请内存时会发生什么" tabindex="-1"><a class="header-anchor" href="#申请内存时会发生什么"><span>申请内存时会发生什么？</span></a></h2><p>malloc申请内存时会经历以下步骤：</p><ol><li><strong>查找内存</strong>。搜索空闲内存块，如果能找到一块大小合适的内存就直接分配</li><li><strong>申请扩存</strong>：malloc找不到一块合适的空闲内存，这时候调用brk系统调用扩大堆区来获得更多的空闲内存。</li><li><strong>分配虚拟内存</strong>：调用brk后进入内核态，os为应用的堆增加虚拟内存，不是增加物理内存。</li><li><strong>二次内存查找</strong>：brk执行完成后malloc再次查找合适的内存块</li><li><strong>分配完成</strong>：应用得到申请到的内存，程序继续运行</li><li><strong>缺页中断</strong>：申请读写新申请的内存时会出现缺页中断，用户态转为内核态，操作系统此时会从物理空闲页中找到所需的物理页分配给应用，然后在页表中记录，同时从磁盘中读取内容填充到物理页中。内核态转回用户态，程序继续。</li></ol><h2 id="java-new一个对象会发生什么" tabindex="-1"><a class="header-anchor" href="#java-new一个对象会发生什么"><span>Java New一个对象会发生什么？</span></a></h2><h3 id="tlab" tabindex="-1"><a class="header-anchor" href="#tlab"><span>TLAB</span></a></h3><p>TLAB是线程本地分配缓冲区，他占用的是Eden区，但是基本上只是Eden区的1%的大小。堆内存时共享的，如果全都在堆上分配对象，那么就会造成很严重的内存并发问题。使用TLAB技术就可以避免加锁带来的效率降低。</p><p>首先看该对象的类是否已经加载过了，判断方法是在运行时常量池中查找是否能定位到一个类的符号引用，并且检查这个类是否已经被加载、接续和初始化过了。如果没有加载类，那么就要先加载对应的类然后再尝试new一个对象。</p><p>假定类已经初始化过了，那么new一个对象可能会经历以下过程。</p><ol><li>编译器通过逃逸分析确定对象是否能够进行标量替换，如果可以就直接在栈上分配</li><li>如果逃逸分析后必须在堆上分配时，首先在TLAB上分配</li><li>如果TLAB不够用就会尝试申请新的TLAB，再次在TLAB上分配</li><li>如果还是不够用，就会尝试对Eden区加锁并分配</li><li>如果Eden区不够用就触发一次Young GC，GC之后再次尝试分配</li><li>如果GC之后还是无法在Eden区分配就会通过分配担保机制将对象直接分配到老年代中</li><li>如果老年代也无法分配就会出发Full GC,如实老年代也不够用，那么就会出现OOM异常。</li><li>分配完成之后就会将内存地址赋值给引用变量。</li></ol>',9),o=[s];function t(r,c){return n(),e("div",null,o)}const h=l(i,[["render",t],["__file","interviews.html.vue"]]);export{h as default};
