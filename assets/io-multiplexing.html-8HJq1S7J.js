import{_ as a,r as l,o as s,c as p,a as e,b as t,w as d,d as o,e as r}from"./app-Ec_z8kpw.js";const c={},h=e("h2",{id:"epoll",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#epoll"},[e("span",null,"epoll")])],-1),_=e("p",null,"epoll是linux独有的IO多路复用函数。我们知道IO多路复用是为了能够批量的获取哪些文件可以读写，从而提高效率。传统的BIO在调用对应的read或者write时会阻塞，基于IO多路复用就可以直接在可读写时再操作",-1),u=e("h3",{id:"主要操作",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#主要操作"},[e("span",null,"主要操作")])],-1),f=e("ol",null,[e("li",null,"epoll_create(int size); 创造一个epoll实例。返回一个epoll的文件描述符"),e("li",null,"epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 注册一个fd对应的事件。"),e("li",null,"epoll_wait(int epfd, struct epoll_event *event, int maxevents, int timeout);event事件回传，maxevents:最大返回事件数量。")],-1),x=e("img",{style:{"border-radius":"0.3125em","box-shadow":"0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08)"},src:"https://cdn.jsdelivr.net/gh/angshn/imageshome@main/imgs/java/io/io-multiplexing/epoll1.png"},null,-1),m=e("br",null,null,-1),b=e("div",{style:{color:"#999","border-bottom":"1px solid #d9d9d9",display:"inline-block",padding:"2px"}}," 图1. epoll的内核结构eventpoll对象",-1),g={href:"https://space.bilibili.com/327009009",target:"_blank",rel:"noopener noreferrer"},v=r('<ul><li><p>就绪列表：对应的socket fd添加到这个队列中，这样很快就能知道哪些fd是就绪的</p></li><li><p>等待队列：调用的时候没有fd就绪那么就会将当前的进程阻塞，有时间到来时会唤醒这个进程。</p></li></ul><p>使用epoll_ctl会将一个fd封装成一个epitem的结构实例，这个实例关联了epoll实例的红黑树，就绪列表和eventpoll对象，epitem有对应的事件时会通过回调函数来唤醒等待队列中的一些进程。</p><h3 id="调用epoll-wait会发生什么" tabindex="-1"><a class="header-anchor" href="#调用epoll-wait会发生什么"><span>调用epoll_wait会发生什么？</span></a></h3><p>进程调用epoll_wait之后，首先检查当前的就绪列表中有没有已经就绪的事件，如果有则直接返回这些事件。如果没有可用的事件，那么就将当前进程信息封装之后添加到进程等待队列中，直到有就绪事件才被唤醒。</p><h3 id="epoll是如何知道哪些fd能读写的" tabindex="-1"><a class="header-anchor" href="#epoll是如何知道哪些fd能读写的"><span>epoll是如何知道哪些fd能读写的？</span></a></h3><p>网卡接收到数据之后会根据数据包的ip地址和端口信息得到一个socket fd号sfd，根据sfd就可以找到对应的epitem从而将当前socket的信息添加到就绪列表之中，接着去唤醒等待队列中的进程去处理这些时间。</p><h3 id="触发时机" tabindex="-1"><a class="header-anchor" href="#触发时机"><span>触发时机</span></a></h3><ol><li>LT level-triggered，默认方式，epoll_wait检测到时间后，如果时间没被处理完成，之后每次调用epoll_wait都会返回该事件。需要额外检查时间是否被处理完了</li><li>ET Edge-triggered, 边缘触发，epoll_wait检测到事件之后当次返回该事件，不管该事件是否被处理完毕。消耗较少。</li></ol><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ol><li>只支持linux</li><li>没有fd数量限制</li><li>epoll更重，因为其维护了一个红黑树</li><li>epoll在高并发情况下性能优异。</li></ol>',10);function w(k,I){const n=l("center"),i=l("ExternalLinkIcon");return s(),p("div",null,[h,_,u,f,e("div",null,[t(n,null,{default:d(()=>[x,m,b]),_:1})]),e("blockquote",null,[e("p",null,[o("图片引用自b站up主"),e("a",g,[o("程序员囧辉"),t(i)])])]),v])}const B=a(c,[["render",w],["__file","io-multiplexing.html.vue"]]);export{B as default};
