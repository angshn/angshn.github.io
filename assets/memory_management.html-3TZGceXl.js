import{_ as a,o as n,c as s,e}from"./app-Ec_z8kpw.js";const r={},t=e('<h2 id="虚拟内存" tabindex="-1"><a class="header-anchor" href="#虚拟内存"><span>虚拟内存</span></a></h2><p>操作系统使用虚拟内存作为物理内存的抽象，应用程序使用内存时使用的是虚拟内存而不是物理内存。设计目的有三个：</p><ul><li>高效性：高效的地址转换</li><li>安全性：不同应用程序内存隔离</li><li>透明性：用户感觉不到虚拟内存的存在</li></ul><h2 id="分段机制" tabindex="-1"><a class="header-anchor" href="#分段机制"><span>分段机制</span></a></h2><p>分段机制将内存分成一段一段的内存块。CPU访问虚拟内存地址中的某个段时，MMU会将虚拟地址查询段表，虚拟地址由两部分组成：<strong>段号</strong>和<strong>段内偏移</strong>。MMU首先通过<strong>段表基址寄存器</strong>找到段表的位置，然后再加上虚拟地址中的段号，然后从段表中取出段起始地址再加上偏移地址就可以得到真实的<strong>物理地址</strong>。</p><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span>优缺点</span></a></h3><p><strong>缺点</strong></p><ul><li>内存外碎片：段与段之间会出现物理内源上的内存碎片，这些碎片会造成资源无法充分利用的问题。</li></ul><h2 id="分页机制" tabindex="-1"><a class="header-anchor" href="#分页机制"><span>分页机制</span></a></h2><p>现代操作系统广泛采用基于分页的虚拟内存设计与实现。在分页机制中，页表是分页机制中的关键部分，他负责记录虚拟页到物理页的映射关系。OS通常将内存划分为若干个相同大小的页，通常是<strong>4K</strong>。与分段机制类似，基于分页的虚拟地址也分为两部分：<strong>虚拟页号</strong>和<strong>页内偏移量</strong>。为了更好的节省空间，分页机制一般采用多级页表，在这种情况下虚拟地址的页号部分通常会包含多级页表，每级页表都对应一个页表中的一项地址。</p><h3 id="重要硬件tlb" tabindex="-1"><a class="header-anchor" href="#重要硬件tlb"><span>重要硬件TLB</span></a></h3><p>TLB是转址旁路缓存(Translation Lookaside Buffer, TLB)，用来加速地址翻译的过程。具体来说，<strong>TLB</strong>缓存了虚拟页号到物理页号的映射关系。MMU会将虚拟地址中的虚拟页号直接在TLB中查询缓存项，如果查询到了就可以直接获取物理页号，而不用再次在多级页表中查询。能够TLB查询到物理页号叫做TLB命中(TLB hit)，反之叫做TLB未命中(TLB miss)。</p><h2 id="换页与缺页异常" tabindex="-1"><a class="header-anchor" href="#换页与缺页异常"><span>换页与缺页异常</span></a></h2><p><strong>换页</strong>：虚拟内存中的换页机制是为了在物理内存不够的时候，将若干物理页的内存写到磁盘等大容量存储设备上，然后回收一部分物理内存页用于其他应用的申请使用。当回收物理页时，将其在页表中的页表项清楚，同时记录物理页在磁盘上的对应位置。这叫做物理页P换出。</p><p><strong>缺页异常</strong>：访问已分配但未映射至物理内存的虚拟页时，就会出发缺页异常。CPU会运行预先设置的缺页异常处理函数，找到一个空闲的物理页，将之前写到磁盘上的数据重新加载到该物理页中，并且在页表中记录映射关系。该过程被称为<strong>换入</strong>(swap in)。</p><h2 id="页替换算法" tabindex="-1"><a class="header-anchor" href="#页替换算法"><span>页替换算法</span></a></h2><h3 id="opt算法" tabindex="-1"><a class="header-anchor" href="#opt算法"><span>OPT算法</span></a></h3><p>OPT算法叫做最优策略，选择一个未来很长时间内不再访问的页来换出。只是理想中的最优方法，无法实现</p><h3 id="fifo算法" tabindex="-1"><a class="header-anchor" href="#fifo算法"><span>FIFO算法</span></a></h3><p>先进先出，OS维护一个队列，每个新换入内存的物理页号都添加到队列最后面，要换出时选择一个队头位置的物理页即可。</p><p>简单但是低效，通常表现不佳。</p><h3 id="lru策略" tabindex="-1"><a class="header-anchor" href="#lru策略"><span>LRU策略</span></a></h3><p>LUR(Least Recently Used)选择最久未被访问的页换出。OS维护一个链表，如果一个页被访问时，将该物理页的页号添加在链表的尾端，每次换出时选择队头的页换出。</p><p>该算法经常被使用。</p>',24),o=[t];function h(p,i){return n(),s("div",null,o)}const c=a(r,[["render",h],["__file","memory_management.html.vue"]]);export{c as default};
