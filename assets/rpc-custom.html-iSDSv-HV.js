import{_ as e,o as t,c as a,e as n}from"./app-Ec_z8kpw.js";const i={},r=n('<h2 id="技术点" tabindex="-1"><a class="header-anchor" href="#技术点"><span>技术点</span></a></h2><ul><li>使用Netty作为网络传输框架</li><li>使用Kyro作为序列化机制的实现</li><li>使用Zookeeper作为服务注册和发现中心</li><li>客户端调用服务服务提供者时应用负载均衡：随机性算法和一致性哈希算法</li><li>集成Spring使用注解注册服务和服务消费</li><li>使用服务版本号version和组group区分服务，方便服务升级。</li><li>SPI机制加载接口的实现类</li><li>使用自定义消息体实现通信协议，同时解决了TCP粘包拆包的问题</li><li>使用Gzip压缩数据包</li></ul><h2 id="rpc调用流程" tabindex="-1"><a class="header-anchor" href="#rpc调用流程"><span>RPC调用流程</span></a></h2><h2 id="netty网络传输" tabindex="-1"><a class="header-anchor" href="#netty网络传输"><span>Netty网络传输</span></a></h2><h3 id="为什么使用netty作为传输框架" tabindex="-1"><a class="header-anchor" href="#为什么使用netty作为传输框架"><span>为什么使用Netty作为传输框架</span></a></h3><p>Netty是一个基于NIO的非阻塞IO框架，他在NIO的基础之上又做了封装，避免了直接使用NIO开发带来的各种不便和极高维护难度，使得基于NIO的开发很方便</p><h3 id="除了netty还有哪些选择" tabindex="-1"><a class="header-anchor" href="#除了netty还有哪些选择"><span>除了Netty还有哪些选择？</span></a></h3><p>直接使用Socket也是一个不错的选择，但是Netty同时支持基于BIO的Socket传输方式。</p><h3 id="netty在rpc中的角色" tabindex="-1"><a class="header-anchor" href="#netty在rpc中的角色"><span>Netty在RPC中的角色</span></a></h3><p>Netty在RPC中可以应用在客户端和服务端。客户端每次发送请求前需要先发起连接请求，成功之后</p>',10),s=[r];function c(h,l){return t(),a("div",null,s)}const o=e(i,[["render",c],["__file","rpc-custom.html.vue"]]);export{o as default};
